---
title: "SING Bioinformatics Workshop"
format: 
  html:
    toc: true
    toc-depth: 3
    toc-expand: true
    embed-resources: true
    theme: litera
---


```{r}
.libPaths("/projects/teaching/sing_guam/workshop_env/R/")
# install.packages("PACKAGE", lib = "/projects/teaching/sing_guam/workshop_env/R/")
library(tidyverse)
```



## Setup and Environment

The following is run in `Terminal` to load the needed software

<!-- This will become a single script to hide the detail -->
<!-- e.g. source ~/sing_guam/load_software.sh -->

```
BASE=/projects/teaching/sing_guam                                                                                                                          
## Make conda available
source ${BASE}/miniconda3/etc/profile.d/conda.sh
conda activate ${BASE}/workshop_env           
```

<!-- Include a picture of rstudio and through out include pictures to indicate which tab console/terminal people need to be in -->


Below is a schematic of the structure of the workshop files and directories (folders)
<!-- this structure is currently reflective of intention - will be updated once everything is ironed out -->
```
~/sing_guam/
  |-data/
  |   |- aligned/
  |   |- fastq/
  |   |- reference/
  |- workshop.html
  |- workshop.qmd
  -- load_software.sh
```

### What is the 1000 Genomes Project

<!-- Very brief introduction into where the data being used comes from -->

## From the sequencer to analysis-ready data

The data file that comes out of the sequencer will look like this:

> \@HWI-M01237:20:000000000-A5R87:1:1101:15995:1759 1:N:0:CCTAGGT
>
> TCTGAGGAGCTCTAATAACAAGCTCCATCTGCCTACGTCAAACCGACTTAAAAGCACTCAAGATCGGAAGTGCACACGTCTGAACTCCAGTCACCCTAGGTATCTCGTATGCCGTCTTCTGCTTGTACAAAAAAAAATTCTCTTTT
>
> +HWI-M01237:20:000000000-A5R87:1:1101:15995:1759 1:N:0:CCTAGGT
>
> FFFFBD?11GGGGCGGB3B110AFGC1FFH1EAF1B0BA0/1AA//AAE1111101ABB0111ABA///?1B12\@1B/F?G/1B1F1B11F11B1B\>0\>0\@BF1B2EF/B0\>BE\</B\<2\>11B\>\<0\>22110?////01111?1?1

Strings of DNA base pairs, identifiers, and encoded information about the quality of the sequencing run. The data then undergoes quite a bit of processing before it can be used for analysis. The general pipeline is this:

1.  First, the quality of the data is assessed to check see how well the sequencing went and how much we can trust the sequencer’s calls.
2.  This can also include trimming of low-quality sequences or adapters (base pairs attached to the target DNA to aid in sequencing)
3.   You may sequence “off-target” portions of DNA – these can be identified and/or removed by comparing your sequences to a large database
4.   The sequence data is then mapped to a reference
5.  Some intermediary steps like removing duplicate sequences, sorting, and indexing help make the following steps quicker
6.   In areas where many reads are mapped but in which variation is present, variants are called. These may be variation at a single base pair (SNP), or variation across many base pairs (structural variation)
7.   Variants are filtered and checked for quality, and be then be annotated and classified
8.   Further analysis can now take place

The pipeline can be represented in the figure below:

![](images/analysis-pipeline.png){width="398"}

Fastq format

```
less -S fastq/
```

### Aligning reads

Let’s take a closer look at how some portions of the pipeline will look from the bioinformatic perspective. We can begin by aligning some reads from the sequencer –we will align a subset of reads to a gene called ABCG2. This is a gene on the fourth human chromosome that creates a protein involved in transport across cell membranes.

**NB: CODE TO BE CLEANED/TESTED, NEED FILES?**

`bwa mem in.ref fasta.1 fasta.2 > ./mapped_reads.sam`

After this has finished, let’s take a look at the output with a viewer

`samtools tview ./mapped_reads.sam`

You can navigate with the arrow keys, or press `g` to jump to a particular region.

We see that each read has been placed somewhere along the reference, there is a lot of overlap at each position. However, there is some variation present- some reads have one or more base pairs that are different from the reference sequence. When we have enough confidence that the different base pair is not an artifact of the sequencing, we call a variant – that is, identify a SNP – at that position.

We can call variants along the entire genome to get a sense of how much variation is present in the sample(s) of interest. Unfortunately, we won’t have time to do any variant calling ourselves today, but you can already see the logic of how this works here.

When you're ready, exit the viewer by pressing the <kbd>Q</kbd> key.
```
hom 0/0 https://ftp.1000genomes.ebi.ac.uk/vol1/ftp/phase3/data/HG00096/alignment/HG00096.mapped.ILLUMINA.bwa.GBR.low_coverage.20120522.bam
het 0/1 https://ftp.1000genomes.ebi.ac.uk/vol1/ftp/phase3/data/HG00102/alignment/HG00102.mapped.ILLUMINA.bwa.GBR.low_coverage.20130415.bam
hom 1/1 https://ftp.1000genomes.ebi.ac.uk/vol1/ftp/phase3/data/HG00111/alignment/HG00111.mapped.ILLUMINA.bwa.GBR.low_coverage.20120522.bam
```


```
aligned
```



```
samtools tview rs2231142_hom_ref_example.bam -p 4:89052323 ../../reference/human_g1k_v37.fasta
```


```
samtools tview rs2231142_het_example.bam -p 4:89052323 ../../reference/human_g1k_v37.fasta
```


```
samtools tview rs2231142_hom_alt_example.bam -p 4:89052323 ../../reference/human_g1k_v37.fasta
```

## Population stratification by PCA’s

We might want to visualize what variation looks like in different populations across the entire genome. We can do this with a technique called a Principal Components Analysis (PCA). This type of analysis allows us to assess the relationships between groups on a geometric scale. Generally speaking, groups that are more similar will be closer together on a PCA plot, while groups that are more different will be further apart.

MORE TO FILL IN HERE


Principal component analysis is a statistical dimension reduction technique that transforms potentially
correlated variables into a linear and non-correlated set of variables. In a genetic context PCA is
used to reduce variation at many thousands of markers into a handful of components that represent
the majority of the variation of the data (Patterson et al., 2006). The components are ordered such
that the first principal component (PC) captures the most variation, with each subsequent component
capturing less. These components often, but not necessarily, represent population differences and
population substructure.

To calculate the principal components of the genetic data, all populations and chromosomes were combined into a single VCF
file with BCFtools v1.3.1, and then the independent markers were identified via Plink v1.9b4.9, using
a sliding window to remove markers that had an inter-marker LD R2 > 0.2, with windows of 50 kb
and a slide of 5 markers. The first 10 principle components were calculated using smartPCA v13050
from Eigensoft v6.0.1 (Price et al., 2006). The following code was used to accomplish these steps.

```
#combine the chromosomes
bcftools concat \
-O z \
-o -o NZ_1KGP_allchr.vcf.gz \
--threads 10 $(ls NZ_1KGP.chr*gz | sort -n -t'r' -k2)
#find the independent markers
plink1.9b4.9 --vcf NZ_1KGP_allchr.vcf.gz \
--maf 0.1 \
--indep-pairwise 50 5 0.2 \
--out NZ_1KGP_allchr

# create an empty affection file that is required for Plink to use the --make-pheno
# which in turn is required for the creation of the ped file just the way
# SmartPCA wants it
touch cases.txt
plink1.9b4.9 --vcf NZ_1KGP_allchr.vcf.gz \
--extract NZ_1KGP_allchr.prune.in \
--recode \
--out NZ_1KGP_allchr_indep \
--make-pheno cases.txt '*'
# create the eigenstrat file
echo -e "genotype: 1KGP_allchr_indep.ped\nsnpname: \
1KGP_allchr_indep.map\nindivname: \
1KGP_allchr_indep.ped\noutputformat: \
EIGENSTRAT\ngenotypeoutname: \
1KGP_allchr_indep.eigenstratgeno\nsnpoutname: \
1KGP_allchr_indep.snp\nindivoutname: \
1KGP_allchr_indep.ind\nfamilynames: \
NO" > par.PED.EIGENSTRAT
# calculate the principle components
convertf -p par.PED.EIGENSTRAT > eigen.log
smartpca.perl \
-i 1KGP_allchr_indep.eigenstratgeno \
-a 1KGP_allchr_indep.snp \
-b 1KGP_allchr_indep.ind \
-o 1KGP_allchr_indep_eigen.pca \
-p 1KGP_allchr_indep_eigen \
-e 1KGP_allchr_indep_eigen.eval \
-l 1KGP_allchr_indep_eigen.log \
-m 0

```


```{r}
pca_data <- read_delim("/projects/teaching/sing_guam/workshop_data/data/1KGP/PCA/1KGP_allchr_indep_eigen.pca.evec.tsv", col_names = c("sample", paste0("PC",1:10),"case_control"), comment = "#", col_select = -"case_control") %>% left_join(
read_delim("/projects/teaching/sing_guam/workshop_data/data/1KGP/integrated_call_samples_v3.20130502.ALL.panel", col_names = TRUE, col_select = c("sample", "pop","super_pop")), by = "sample")

pc_loadings <- read_delim("/projects/teaching/sing_guam/workshop_data/data/1KGP/PCA/1KGP_allchr_indep_eigen.pca.evec.tsv", col_names = FALSE, n_max = 1)
```
```{r}
theme_set(theme_bw())

ggplot(data = pca_data, aes(x = PC1, y = PC2, colour = super_pop)) + geom_point()

```



## **Variants – what can we do with them?**

Once you’ve mapped reads and called your variants, what does one do with them? How does one use this data? Let’s assume we’re working with human data in a medical genetics context. We’ve identified a variant that seems to be associated a particular clinical outcome. We might be interested to know what the allele frequency of this variant is (i.e., how common is it?) Let’s assess the frequency of a variant called rs2231142, which is located in the ABCG2 gene we mapped earlier:

ensembl: 
Genomic context: https://grch37.ensembl.org/Homo_sapiens/Location/View?db=core;r=4:89051823-89052823;v=rs2231142;vdb=variation;vf=253533488
Variant info: https://grch37.ensembl.org/Homo_sapiens/Variation/Explore?r=4:89051823-89052823;v=rs2231142;vdb=variation;vf=253533488
Population frequencies: https://grch37.ensembl.org/Homo_sapiens/Variation/Population?db=core;r=4:89051823-89052823;v=rs2231142;vdb=variation;vf=253533488
Phenotypes: https://grch37.ensembl.org/Homo_sapiens/Variation/Phenotype?db=core;r=4:89051823-89052823;v=rs2231142;vdb=variation;vf=253533488


dbsnp: https://www.ncbi.nlm.nih.gov/snp/rs2231142#frequency_tab


**TBC: gnomAD browser? Some simple code?**

https://gnomad.broadinstitute.org/variant/4-88131171-G-T?dataset=gnomad_r4

1.  Is the frequency of this variant the same across the globe? Are there populations with a higher frequency than others?
2.  Is this variant relevant to human health? Let’s explore some resources for finding information of clinical relevance.

**TBC: ClinVar? dbSNP?**

1.   Is the variant associated with any clinical conditions?


# **Mitochondrial Haplotypes**

Mitochondria contain their own short, circular DNA sequences that are distinct from the rest of the genome. They are present in large copy number, mutate relatively rapidly, and their small size and distinctiveness makes them easy to target and sequence, especially in large, mixed samples such as at the population level.

Mitochondrial DNA is inherited maternally and does not undergo recombination on the way. These characteristics make them particularly suitable for Haplotype analysis. Haplotypes are blocks of SNPs that get inherited together, and which are eventually broken up by recombination, the ‘mixing’ of maternal and paternal DNA that occurs during the formation of eggs and sperm. The stability of mitochondrial haplotypes makes them useful for tracking long term evolutionary patterns, such as population stratification.

As populations become separated and accumulate mutations, haplotypes unique to those populations are formed. Haplotype analysis aims to reconstruct the relationships between haplotypes, and family trees (phylogenies) can be reconstructed that trace their evolution. We will be using 1000 Genomes data to explore human haplotype variation across the globe.

In the lower right-hand side of R Studio, find the file

`workshop_data/data/1KGP/ALL.chrMT.phase3_callmom-v0_4.20130502.genotypes.vcf.gz`

and select by clicking the checkbox. Then click on the settings gear to open a drop-down menu and select Export to save it to your computer locally.

In a web browser, navigate to <https://haplogrep.i-med.ac.at/> and upload the file using the `Browse...` button. Choose the following options:

File Format: VCF\
Phylogenetic tree: PhyloTree 17.0\
Distance Function: Kulczynski\
Output: (leave blank)

Then select **Upload and Classify**

The program may take a few minutes to run before it opens your results in a new menu. These results will show you the haplotype clusters found in the file, and some quality control metrics.

1.  Click on a haplotype cluster to open a new window, which will describe the prevalence of that cluster in different global populations. Haplogrep will also display a phylogenetic tree that describes the relationships of haplogroups in the cluster.
2.  Navigate to the Samples table at the top of the page. Here, you can click on any variant in the Mutations column to explore metrics specific to that variant, such as its frequency in different populations.
3.  Continue to explore the outputs of Haplogrep for this global sample of individuals.

## **Haplotype tree**

Let’s create our own phylogenetic tree for some population in the database. Choose a population code from the table below and run the following code in `Terminal`:

`grep "PEL" test_dir/1KGP-phase3-samples.txt | awk '{print $1}' > ./samples-of-interest.txt`

NB: change `PEL` to any of the codes listed in the table below to select a particular population

`bcftools view --samples-file test_dir/samples-of-interest.txt --output ./pop.chrMT.phase3_callmom-v0_4.20130502.genotypes.vcf.gz workshop_data/data/1KGP/ALL.chrMT.phase3_callmom-v0_4.20130502.genotypes.vcf.gz`

|     |                                                               |
|:---:|---------------------------------------------------------------|
| ACB | African Caribbean in Barbados                                 |
| ASW | African Ancestry in Southwest USA                             |
| CDX | Chinese Dai in Xishuangbanna, China                           |
| CEU | Utah residents with ancestry from northern and western Europe |
| CHB | Han Chinese in Beijing, China                                 |
| CHS | Han Chinese South, China                                      |
| CLM | Colombian in Medellin, Colombia                               |
| FIN | Finnish in Finland                                            |
| GBR | British From England and Scotland, UK                         |
| GIH | Gujarati Indians in Houston, Texas, USA                       |
| IBS | Iberian populations in Spain                                  |
| JPT | Japanese in Tokyo, Japan                                      |
| KHV | Kinh in Ho Chi Minh City, Vietnam                             |
| LWK | Luhya in Webuye, Kenya                                        |
| MXL | Mexican Ancestry in Los Angeles, California, USA              |
| PEL | Peruvian in Lima, Peru                                        |
| PUR | Puerto Rican in Puerto Rico                                   |
| TSI | Toscani in Italia                                             |
| YRI | Yoruba in Ibadan, Nigeria                                     |

: ^Table\ from\ Diroma\ et\ al.,\ 2014\ BMC\ Genomics\ (<https://doi.org/10.1186%2F1471-2164-15-S3-S2>)^

Now run the following code in the R `Console` to create a dendrogram, a tree that groups samples by their similarity.

`library(fastreeR)`

`vcfFile <- ("./pop.chrMT.phase3_callmom-v0_4.20130502.genotypes.vcf.gz")`

`myVcfDist <- fastreeR::vcf2dist(inputFile = vcfFile, threads = 2)`

`myVcfTreeStats <- stats::hclust(myVcfDist)`

`plot(myVcfTreeStats, ann = FALSE, cex = 0.5)`

1.  How much variation is present in your population?
2.  How many major groups are present?
3.  Looking at the vertical axis, how much variation is actually present in the group? How different is this to other groups?


# Appendix

## BASH reference



## R reference

